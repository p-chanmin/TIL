# 단일처리기 스케줄링



## 처리기 스케줄링의 유형

- 처리기 스케줄링의 정의
  - 응답 시간이나 처리량, 효율성을 증대시키기 위해 처리기가 다음에 실행할 프로세스를 선택하는 것
- 선후 관계에 따른 스케줄링의 유형
  - 장기 스케줄링 :  degree of multiprogramming을 결정
  - 중기 스케줄링 : swapper의 역할
  - 단기 스케줄링 :  CPU 스케줄링에 해당
- 스케줄러의 성능
  - 프로세스들이 일생 동안 각종 큐에서 대기하는 시간을 얼마나 줄일 수 있을 것이냐 하는 문제



### 처리기 스케줄링의 유형 : 장기 스케줄링

- 새 프로세스의 시스템 진입 허용 여부를 결정
- 멀티 프로그래밍의 정도를 결정함



### 처리기 스케줄링의 유형 : 중기 스케줄링

- 스와핑 기능의 일부
  - 스왑 공간으로 쫓겨나간 프로세스 전체 또는 일부 중 어어느 것을 다시 주 메모리로 스왑인 할 것인지



### 처리기 스케줄링의 유형 : 단기 스케줄링

- 디스패쳐 라고도 함
  - 장기/중기 스케줄러보다 매우 자주 실행
  - 세밀한 기준으로 다음 번에 실행시킬 프로세스를 선정
- 단기 스케줄러 실행 시점
  - 클럭 인터럽트 - 타이머 시간 할당량 만료시
  - 입출력 인터럽트
  - 운영체제 시스템 호출



## 스케줄링 알고리즘 : 단기 스케줄링 평가 기준

- 사용자 중심 관점 vs 시스템 중심 관점
  - 사용자 중심 관점 : 응답시간
  - 시스템 중심 관점 : 처리량
- 성능 중심 관점 vs 성능 외적 관점
  - 성능 중심 관점 : 대부분 정량적인 척도로 측정 용이함
  - 성능 외적 관점 : 대부분 정성적인 척도로 측정이 어려움



### 스케줄링 알고리즘 : 다양한 스케줄링 정책들



#### 평균반환 시간 (average turnaround time)

* 각 프로세스의 (종료시간 - 도착시간) 평균값



### First-Come-First-Served (FCFS)

- FIFO(First-In-First-Out) 라고도 함
- 프로세스는 준비 상태가 되면 준비 큐에 들어감
- 현재 실행 중인 프로세스가 실행을 종료하면 준비 큐에서 대기 중 이던 프로세스 중 가장 오랫동안 기다렸던 프로세스가 다음 번 실행 프로세스로 선정
- FCFS는 짧은 프로세스보다는 긴 프로세스에게 유리
- 비중단(Nonpreemptive) 모드로 동작
- 입출력 중심의 프로세스보다 처리기 중심 프로세스를 우대하는 경향



### Shortest-Process-Next (SPN)

- FCFS의 긴 프로세스 우대 편향성 완화 방법으로
- 가장 짧은 프로세 스를 먼저 실행시키는 정책
- 종료 시까지 남아 있는 실행시간이 가장 짧은 프로세스를 다음 번 프로세스로 선택
- 비중단(Nonpreemptive) 모드로 동작
- 실행 시간이 짧은 프로세스가 (비록 늦게 도착했더라도) 긴 프로 세스들보다 먼저 스케줄링
- 단점 : 짧은 프로세스들이 지속적으로 시스템에 진입한다면 이들 보다 상대적으로 긴 프로세스가 기아 상태에 빠질 수 있음
-  SPN 구현 상의 문제점
  - 각 프로세스가 요구하는 총 실행 시간을 미리 알아야 함
  - 미리 알기가 어렵기 때문에 시스템은 이를 유추할 수 있어야 함
  - 유추 방법 - 단순 평균, 지수적 평균



### Shortest-Remaining-Time (SRT)

- SPN의 중단(preemptive) 모드 버전에 해당
- 예상되는 남아있는 실행 시간이 가장 짧은 프로세스가 다음 번 프로세스로 선택
- "새로 도착한 프로세스의 예상되는 남아있는 실행 시간" < "현재 실행 중인 프로세스의 예상 실행 시간" 이면 늦게 도착했더라도 현재 실행 중인 프로세스를 중단하고 곧장 선택
- 단점
  - 매 스케줄링 때마다 프로세스들의 남아있는 실행 시간을 평가해야 하는 부담
  - 긴 프로세스가 기아 상태에 빠질 가능성



### 라운드-로빈(Round-Robin)

- FCFS에서 짧은 프로세스가 피해보는 현상 완화
- 시간을 측정하고 있다가 어떤 긴 프로세스가 일정 시간 이상을 넘어가는 순간 실행을 강제로 중단시키는(preemption) 것
- 라운드-로빈 스케줄링 기법 동작 방식
  - 클럭 인터럽트가 발생하면 클럭 인터럽트 서비스 루틴이 실행
  - 클럭 인터럽트 서비스 루틴은 현재 실행 중이던 프로세스를 준비 큐로 이동
  - 준비 큐에서 FCFS 방식으로 다음 번 프로세스를 골라 실행
- 시간 할당량(time slicing, 또는 time quantum) 기법이라고도 함
- 시간할당량의 크기(q)가 라운드-로빈 성능에 미치는 영향
  - 시간할당량이 너무 작으면 문맥교환 오버헤드가 증가
  - 시간할당량이 너무 크면 FCFS와 비슷해짐
- 시간할당량의 권장 길이
  - 프로세스가 사용자와 최소한 한 번 이상 대화하기에 충분하거나
  - 프로세스 내의 어떤 한 함수 정도는 실행을 마칠 수 있는 충분한 길이
- 단점 : 입출력 중심 프로세스보다 처리기 중심 프로세스를 우대 할 수 밖에 없는 현상



### Highest-Response-Ratio-Next (HRRN)

- 준비 큐에 있는 프로세스 중 R 값(응답 비율)이 가장 큰 프로세 스를 다음 번 프로세스로 선택

  - 프로세스가 시스템 내에 머문 시간(즉, 프로세스의 나이)을 고려
  - 서비스 시간이 짧은 프로세스의 R 값이 상대적으로 크기 때문에 짧 은 프로세스를 우대하는 면
  - 대기 시간 때문에 시스템에 오래 머문 긴 프로세스도 오래 머물면 머물수록 R 값이 커지기 때문에 홀대 받지는 않음

- 응답 비율의 정의

  <img src="https://latex.codecogs.com/svg.image?R&space;=&space;\frac{w&space;&plus;&space;s}{s}" title="https://latex.codecogs.com/svg.image?R = \frac{w + s}{s}" />

  R = 응답 비율

  w = 처리기를 기다리며 대기한 시간

  s = 예상되는 서비스 시간



### 피드백 (Feedback) 스케 줄링

- 프로세스들의 예상되는 서비스 시간을 미리 알아낼 필요가 없음
- 중단점을 만날 때마다 프로세스는 한 단계 낮은 우선 순위의 준비 큐로 강등되어 진입
- 새로 도착한 프로세스일수록, 그리고 짧은 프로세스 일수록 오래된 프로세스나 긴 프로세스보다 우대 받는 정책
- 변형 : 모든 큐에서 고정된 시간 할당량이 있는 라운드 로빈 방 식으로 스케줄링
- 변형 : 시간 할당량의 크기를 큐 별로 다르게 함
- 우선순위가 높은 프로세스를 먼저 실행
- 우선순위별 대기 큐를 별도로 두고, 높은 우선순위의 대기 큐에 있는 프로세스를 먼저 실행



## 정규화된 반환 시간

- 정규화된 반환시간(Normalized Turnaround Time)  = Tr / Ts
- Tr = 턴어라운드 시간 또는 시스템에 머문 시간; 시스템 내에 총 머문 시간(대기 시간 + 실행 시간)
- Ts = 평균 서비스 시간; 실행 상태에 머물렀던 평균 시간
- 각 프로세스의 반환시간의 영향을 반영하는데 적합한 평가지표



## 스케줄링 정책들의 성능 비교

- 2가지 비교 분석 방법 사용
  - 큐잉 분석
  - 시뮬레이션 모델링



### 큐잉분석

- 관찰에 의하면 프로세스의 서비스 시간에 관계없이 다음 프로세 스를 선택하는 스케줄러는 다음과 같은 관계
- <img src="https://latex.codecogs.com/svg.image?\frac{T_r}{T_s}&space;=&space;\frac{1}{1-\rho&space;}" title="https://latex.codecogs.com/svg.image?\frac{T_r}{T_s} = \frac{1}{1-\rho }" />
- ρ = 처리기 이용율



## 스케줄링 알고리즘: Fair-Share 스케줄링

- 프로세스 집합 단위의 스케줄링 방식

- "공정함을 나누어 갖는다."라는 의미가 함축

-  Fair-Share 스케줄러의 동작 예

  - 세 개의 프로세스가 두 개의 그룹을 구성
  - 각 그룹의 가중치는 0.5
  - 스케줄링 순서 : A, B, A, C, A, B, …

  