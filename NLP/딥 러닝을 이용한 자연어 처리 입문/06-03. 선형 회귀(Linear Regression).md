> 출처 : https://wikidocs.net/21670



# 3. 선형 회귀(Linear Regression)

머신 러닝에서 쓰이는 용어인 가설(Hypothesis), 손실 함수(Loss Function) 그리고 경사 하강법(Gradient Descent)에 대한 개념과 선형 회귀



## 3.**1. 선형 회귀(Linear Regression)**

다른 변수의 값을 변하게하는 변수를 x, 변수 x에 의해서 값이 종속적으로 변하는 변수 y라고 해보자.

이때 변수 x의 값은 독립적으로 변할 수 있는 것에 반해, y값은 계속해서 x의 값에 의해서, 종속적으로 결정되므로 x를 독립 변수, y를 종속 변수라고 한다.

선형 회귀는 한 개 이상의 독립 변수 x와 y의 선형 관계를 모델링을 말한다.

* **단순 선형 회귀 분석(Simple Linear Regression Analysis)**

  <img src="https://latex.codecogs.com/svg.image?y&space;=&space;{wx&space;&plus;&space;b}" title="y = {wx + b}" />

  위의 수식은 단순 선형 회귀의 수식

  여기서 독립 변수 x와 곱해지는 **값 w를 머신 러닝에서는 가중치(weight)**, 별도로 더해지는 **값 b를 편향(bias)**이라고 한다.

* **다중 선형 회귀 분석(Multiple Linear Regression Analysis)**

  <img src="https://latex.codecogs.com/svg.image?y&space;=&space;{w_1x_1&space;&plus;&space;w_2x_2&space;&plus;&space;...&space;w_nx_n&space;&plus;&space;b}" title="y = {w_1x_1 + w_2x_2 + ... w_nx_n + b}" />

  y는 여전히 1개이지만 이제 x는 1개가 아니라 여러 개가 되었다. 이를 다중 선형 회귀 분석이라고 한다.



## 3.**2. 가설(Hypothesis) 세우기**

**단순 선형 회귀**를 가지고 문제를 풀어봅시다. 어떤 학생의 공부 시간에 따라서 다음과 같은 점수를 얻었다는 데이터가 있다.

| hours(x) | score(y) |
| :------- | :------- |
| 2        | 25       |
| 3        | 50       |
| 4        | 42       |
| 5        | 61       |

이를 좌표 평면에 그려보면 다음과 같다.

![img](https://wikidocs.net/images/page/53560/%EA%B7%B8%EB%A6%BC1.PNG)

이 학생이 6시간, 7시간, 8시간을 공부하였을 때의 성적을 예측

x와 y의 관계를 유추하기 위해서 수학적으로 식을 세워보게 되는데 머신 러닝에서는 이러한 식을 **가설(Hypothesis)** 이라고 한다.

아래의 H(x)에서 H는 Hypothesis를 의미

<img src="https://latex.codecogs.com/svg.image?H(x)&space;=&space;{wx&space;&plus;&space;b}" title="H(x) = {wx + b}" />

![img](https://wikidocs.net/images/page/21670/W%EC%99%80_b%EA%B0%80_%EB%8B%A4%EB%A6%84.PNG)

위의 그림은 w와 b의 값에 따라서 천차만별로 그려지는 직선의 모습을 보여준다.

결국 선형 회귀는 주어진 데이터로부터 y와 x의 관계를 가장 잘 나타내는 직선을 그리는 일

어떤 직선인지 결정하는 것은 w와 b의 값이므로 선형 회귀에서 해야할 일은 결국 적절한 w와 b를 찾아내는 일



## 3.**3. 비용 함수(Cost function) : 평균 제곱 오차(MSE)**

주어진 데이터에서 x와 y의 관계를 w와 b를 이용하여 식을 세우는 일을 가설

머신 러닝은 w와 b를 찾기 위해서 실제값과 가설로부터 얻은 예측값의 오차를 계산하는 식을 세우고, 이 식의 값을 최소화하는 최적의 w와 b를 찾아낸다.

이때 실제값과 예측값에 대한 오차에 대한 식을 **목적 함수(Objective function) 또는 비용 함수(Cost function) 또는 손실 함수(Loss function)** 라고 한다.

* **목적 함수(Objective function)**

  함수의 값을 최소화하거나, 최대화하거나 하는 목적을 가진 함수

* **비용 함수(Cost function) 또는 손실 함수(Loss function)**

  값을 최소화하려고 하는 함수

비용 함수는 단순히 실제값과 예측값에 대한 오차를 표현하면 되는 것이 아니라, 예측값의 오차를 줄이는 일에 최적화 된 식이어야 한다.

회귀 문제의 경우에는 주로 **평균 제곱 오차(Mean Squared Error, MSE)**가 사용

---

![img](https://wikidocs.net/images/page/53560/%EA%B7%B8%EB%A6%BC3.PNG)

위의 그래프에 임의의 w의 값 13과 임의의 b의 값 1을 가진 직선

y와 x의 관계를 가장 잘 나타내는 직선을 그린다는 것은 위의 그림에서 모든 점들과 위치적으로 가장 가까운 직선을 그린다는 것과 같다.

오차는 주어진 데이터에서 각 x에서의 실제값 y와 위의 직선에서 예측하고 있는 H(x)값의 차이다.

즉, 위의 그림에서 ↕는 각 점에서의 오차의 크기를 보여준다.

오차를 줄여가면서 w와 b의 값을 찾아내기 위해서는 전체 오차의 크기를 구해야 한다.

오차의 크기를 측정하기 위한 가장 기본적인 방법은 각 오차를 모두 더하는 방법이 있다.

위의 y=13x+1 직선이 예측한 예측값을 각각 실제값으로부터 오차를 계산하여 표를 만들어보면

| hours(x) | 2    | 3    | 4    | 5    |
| :------- | :--- | :--- | :--- | :--- |
| 실제값   | 25   | 50   | 42   | 61   |
| 예측값   | 27   | 40   | 53   | 66   |
| 오차     | -2   | 10   | -9   | -5   |

수식적으로 단순히 '오차 = 실제값 - 예측값' 이라고 정의한 후에 모든 오차를 더하면 음수 오차도 있고, 양수 오차도 있으므로 오차의 절대적인 크기를 구할 수가 없다. 따라서  모든 오차를 제곱하여 더하는 방법을 사용한다.

모든 점과 직선 사이의 ↕ 거리를 제곱하고 모두 더하고, 데이터의 개수인 n으로 나누면, 오차의 제곱합에 대한 평균을 구할 수 있는데 이를 평균 제곱 오차(Mean Squered Error, MSE)라고 한다.

<img src="https://latex.codecogs.com/svg.image?\frac{1}{n}&space;\sum_{i=1}^{n}&space;\left[y^{(i)}&space;-&space;H(x^{(i)})\right]^2&space;=&space;210&space;/&space;4&space;=&space;52.5" title="\frac{1}{n} \sum_{i=1}^{n} \left[y^{(i)} - H(x^{(i)})\right]^2 = 210 / 4 = 52.5" />

y=13x+1의 예측값과 실제값의 평균 제곱 오차의 값은 52.5

평균 제곱 오차의 값을 최소값으로 만드는 w와 b를 찾아내는 것이 정답인 직선을 찾아내는 일

---

**평균 제곱 오차를 w와 b에 의한 비용 함수(Cost function)**

<img src="https://latex.codecogs.com/svg.image?cost(w,&space;b)&space;=&space;\frac{1}{n}&space;\sum_{i=1}^{n}&space;\left[y^{(i)}&space;-&space;H(x^{(i)})\right]^2" title="cost(w, b) = \frac{1}{n} \sum_{i=1}^{n} \left[y^{(i)} - H(x^{(i)})\right]^2" />

모든 점들과의 오차가 클 수록 평균 제곱 오차는 커지며, 오차가 작아질 수록 평균 제곱 오차는 작아진다.

이 평균 최곱 오차. 즉, Cost(w,b)를 최소가 되게 만드는 w와 b를 구하면 결과적으로 y와 x의 관계를 가장 잘 나타내는 직선을 그릴 수 있다.



## 3.**4. 옵티마이저(Optimizer) : 경사하강법(Gradient Descent)**

선형 회귀를 포함한 수많은 머신 러닝, 딥 러닝의 학습은 결국 비용 함수를 최소화하는 매개 변수인 w와 b을 찾기 위한 작업을 수행

이때 사용되는 알고리즘을 **옵티마이저(Optimizer)** 또는 **최적화 알고리즘**

이 옵티마이저를 통해 적절한 w와 b를 찾아내는 과정을 머신 러닝에서 훈련(training) 또는 학습(learning)이라고 부른다.

가장 기본적인 옵티마이저 알고리즘인 **경사 하강법(Gradient Descent)**

---

w는 머신 러닝 용어로는 가중치라고 불리지만, 직선의 방정식 관점에서 보면 직선의 기울기를 의미

기울기가 지나치게 크면 실제값과 예측값의 오차가 커지고, 기울기가 지나치게 작아도 실제값과 예측값의 오차가 커진다. b 또한 마찬가지인데 b가 지나치게 크거나 작으면 오차가 커진다.

편향 b가 없이 단순히 가중치 w만을 사용한 y=wx라는 가설 H(x)를 가지고, 경사 하강법을 수행한다고 해보자.

이에 따라 w와 cost의 관계를 그래프로 표현하면 다음과 같다.

![img](https://wikidocs.net/images/page/21670/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%801.JPG)

기울기 w가 무한대로 커지면 커질 수록 cost의 값 또한 무한대로 커지고, 반대로 기울기 w가 무한대로 작아져도 cost의 값은 무한대로 커진다.

위의 그래프에서 cost가 가장 작을 때는 볼록한 부분의 맨 아래 부분

기계가 해야할 일은 cost가 가장 최소값을 가지게 하는 w를 찾는 일이므로, 볼록한 부분의 맨 아래 부분의 w의 값을 찾아야 한다.

기계는 임의의 랜덤값 w값을 정한 뒤에, 맨 아래의 볼록한 부분을 향해 점차 w의 값을 수정해나간다.

이를 가능하게 하는 것이 경사 하강법(Gradient Descent) 이다.

경사 하강법은 미분을 배우게 되면 가장 처음 배우게 되는 개념인 한 점에서의 순간 변화율 또는 다른 표현으로는 접선에서의 기울기의 개념을 사용

![img](https://wikidocs.net/images/page/21670/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%803.JPG)

위의 그림에서 초록색 선은 w가 임의의 값을 가지게 되는 네 가지의 경우에 대해서, 그래프 상으로 접선의 기울기를 보여준다.

맨 아래의 볼록한 부분으로 갈수록 접선의 기울기가 점차 작아진다는 점

그리고 맨 아래의 볼록한 부분에서는 결국 접선의 기울기가 0이 된다.

즉, cost가 최소화가 되는 지점은 접선의 기울기가 0이 되는 지점이며, 또한 미분값이 0이 되는 지점이다.

경사 하강법의 아이디어는 비용 함수(Cost function)를 미분하여 현재 w에서의 접선의 기울기를 구하고, 접선의 기울기가 낮은 방향으로 w의 값을 변경하고 다시 미분하고 이 과정을 접선의 기울기가 0인 곳을 향해 w의 값을 변경하는 작업을 반복하는 것에 있다.

비용(cost)를 최소화하는 w를 구하기 위해 w를 업데이트하는 식은 다음과 같다. 이를 접선의 기울기가 0이 될 때까지 반복

<img src="https://latex.codecogs.com/svg.image?w&space;:=&space;w&space;-&space;\alpha&space;\frac{\partial&space;}{\partial&space;w}cost(w)" title="w := w - \alpha \frac{\partial }{\partial w}cost(w)" />

현재 w에서의 접선의 기울기와 α와 곱한 값을 현재 w에서 빼서 새로운 w의 값으로 한다는 것을 의미

α는 여기서 학습률(learning rate)이라고 한다.

![img](https://wikidocs.net/images/page/21670/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%804-2.JPG)

위의 그림은 접선의 기울기가 음수일 때, 0일때, 양수일 때를 보여준다.

기울기가 음수면 '음수를 빼는 것'은 곧 '해당 값을 양수로 바꾸고 더하는 것'과 같다. (가령, 어떤 수에서 -2를 뺀다는 것은 해당 숫자에 2를 더하는 것과 같다.)

결국 음수 기울기를 빼면 w의 값이 증가하게 되는데 이는 결과적으로 접선의 기울기가 0인 방향으로 w의 값이 조정된다.

반대로 기울기가 양수면 w의 값이 감소하게 되는데 이는 결과적으로 기울기가 0인 방향으로 w의 값이 조정된다.



그렇다면 여기서 학습률(learning rate)이라고 말하는 α는 어떤 의미를 가질까?

학습률 α은 w의 값을 변경할 때, 얼마나 크게 변경할지를 결정하며 0과 1사이의 값을 가지도록 한다.

학습률은 w를 그래프의 한 점으로보고 접선의 기울기가 0일 때까지 경사를 따라 내려간다는 관점에서는 얼마나 큰 폭으로 이동할지를 결정

학습률 α의 값을 무작정 크게 하면 접선의 기울기가 최소값이 되는 w를 빠르게 찾을 수 있을 것같지만 그렇지 않다.

![img](https://wikidocs.net/images/page/21670/%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%805.JPG)

위의 그림은 학습률 α가 지나치게 높은 값을 가질 때, 접선의 기울기가 0이 되는 w를 찾아가는 것이 아니라 w의 값이 발산하는 상황을 보여준다.

반대로 학습률 α가 지나치게 낮은 값을 가지면 학습 속도가 느려지므로 적당한 α의 값을 찾아내는 것도 중요하다.

