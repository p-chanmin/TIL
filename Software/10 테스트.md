# 테스트



## 테스트의 이해



### 전문가들의 소프트웨어 정의

- IEEE
  - 테스트는 시스템이 명시된 요구를 잘 만족하는지, 즉 예상된 결과와 실제 결과가 어떤 차 이를 보이는지 수동이나 자동으로 검사하고 평가하는 작업
- Zoha Manna
  - 테스트는 시스템의 명세까지 완벽하게 옳다고 확신할 수 없고, 테스트 시스템 그 자체가 맞다고 증명할 수 없기 때문에 프로그램을 완전히 테스트할 수 없다
- Dahl, Dijkstra, Hoare
  - 테스트는 결함이 있음을 보여줄 뿐, 결함이 없음을 증명할 수는 없다



- 소프트웨어에 내에 존재하지만 드러나지 않고 숨어 있는 오류를 발견할 목적으로, 개발 과정에서 생성되는 문서나 프로그램에 있는 오류를 여러 기술을 이용해 검출하는 작업
- 오류를 찾아내 정상적으로 실행될 수 있도록 하는 정도이지, 소프트웨어에 오류가 없음을 확인시켜주지는 못한다.
- 테스트는 오류를 찾고 올바르게 수정하여 프로그램을 작동시킬 수는 있지만,  그 프로그램이 완전하고 정확하다고 증명할 수는 없다. 



### 소프트웨어 테스트의 목표

- 작은 의미
  - 원시 코드 속에 남아 있는 오류를 발견하는 것
  - 결함이 생기지 않도록 예방하는 것
- 큰 의미
  -  개발된 소프트웨어가 고객의 요구를 만족시키는지 확인시켜주는 것
  - 개발자와 고객에게 사용하기에 충분한 소프트웨어임을 보여주는 것
- 개발된 소프트웨어에 신뢰성을 높여주기 위한 작업



### 소프트웨어 테스트의 어려움과 특징

- 테스트 케이스가 적어 효과에 한계가 있다
- 완벽한 테스트 케이스를 도출하기 어렵다
- 테스트를 위한 실제 사용 환경을 구축하기 어렵다
- 작은 실수를 발견하기 어렵다
- 테스트 중요성에 대한 인식이 부족하다
- 고객의 요구 사항을 충족시켜야 한다
- 테스트 단계에서만 수행되는 단순한 활동이 아니라 개발 단계와 함께한다
- 파레토 원리를 적용할 수 있다
- 모듈 단위를 점점 확대해나가며 진행한다
- 완벽한 테스트는 불가능하다
- 개발자와 다른 별도의 팀에서 수행한다
- 살충제 패러독스(테스트 내성) 문제 해결을 위해 테스트 케이스 업데이트가 필요하다



### 테스트에서 결함 관련 용어

- 오류(error)
  - 소프트웨어 개발자에 의해 만들어지는 실수로 결함의 원인이 된다.
- 결함(defect, bug, fault)
  - 오류에 의해 프로그램이 완전치 못한 것으로, 고장의 원인이 된다.
- 고장, 실패(failure) , 문제(problem) , 장애
  - 시스템이 요구 사항대로 작동하지 않는 것을 말한다



### 테스트 절차

1. 테스트 계획
2. 테스트 케이스 설계
3. 테스트 실행 및 평가
4. 테스트 결과 분석
5. 오류 추적 및 수정



#### 테스트 계획

- 테스트 목표 정의
  - 테스트 항목 중에서 어떤 항목을 중점적으로 테스트할 것인지 명확히 나타낸다
- 테스트 대상 및 범위 결정
- 테스트 계획서 작성 및 검토
  - 테스트의 목적, 담당 인원, 테스트 전략과 접근 방법 수립, 필요한 자원 및 자원 확보 일정,  실시할 테스트의 종류, 적용할 테스트 기법, 일정 등에 관한 정보를 기록

#### 테스트 케이스 설계

- 테스트 케이스 설계 기법 정의
- 테스트 케이스 도출
- 원시 데이터 작성

#### 테스트 실행 및 측정

- 테스트 환경 구축
- 테스트 실행 및 측정

#### 테스트 결과 분석

- 테스트 결과 분석
  - 테스트 활동을 통해 얻어진 결과 값과 테스트 계획 단계에서 목표한 값을 비교하여 예정 된 테스트 품질 목표가 달성되었는지를 비교·분석
- 보고서 작성
  - 테스트를 수행한 결과와 테스트를 수행하는 데 사용된 방법 등을 기술
  - 결과에 따른 평가와 권고 사항도 기술

#### 오류 추적 및 수정

- 오류 수정 계획
  - 테스트 결과 보고서를 기반으로 오류가 발생된 위치를 찾아내고, 오류 수정 우선순위를 결 정하여 오류 제거 계획을 세운다.
- 오류 수정
- 수정된 내용 보고



## 테스트의 분류



### 시각에 따른 테스트

- 확인 테스트(verification rest)
  - 각 단계에서 개발자의 시각으로 테스트
  - 설계도 대로 만들었는지 테스트
  - 이전 단계에서 생성된 산출물이 현 단계의 산출물에 정확히 반영되었는지 테스트
- 확인 테스트의 문제점
  - 사용자의 요구가 맞는지 틀리는지는 체크를 안 해보고, 오직 계산 과정이 맞는지 만 검증



- 검증 테스트(validation test)
  - 사용자의 요구 사항대로 만들었는지를 테스트
  - 사용자의 시각에서 테스트
    - 사용자가 원하는 것을 만들었는지
    - 완성된 제품이 사용자의 요구 사항을 모두 충족하는지



- 소프트웨어가 사용자의 목적에 맞게 구현되었지 확인 가능



## 정적 테스트

- 정적 테스트( static test)
  - 프로그램 코드를 실행하지 않고 여러 참여자가 모여 소프트웨어 개발 중에 생성되는 모든 명세나 코드를 검토해서 실패(failures)보다는 결함(defects)을 찾아내는 방법



- 비공식 검토
  - 산출물(문서, 프로그램)을 동료와 함께 책상에서 검사
  - 제품을 검토할 목적으로 하는 간단한 만나서 개별 검토, 동료 검토
- 공식 검토
  - 동료와 전문가들이 수행
  - 결함을 찾기 위해 정의된 절차에 따라 적절히 계획되고 통제
  - 검토회의와 소프트웨어 검사



### 공식 검토

- 공식 검토 내용
  - 원시 코드상에 존재하는 오류 검토
  - 소프트웨어가 사용자의 요구를 충분히 반영했는지 검토
  - 소프트웨어가 미리 정의된 표준을 지키는지 검토
  - 소프트웨어 개발 방식이 일관적인지 검토
  - 소프트웨어

- 공식 검토 수행 절차
  1. 계획
  2. 착수
  3. 개별 준비
  4. 검토회의 수행
  5. 재작업 및 수정
  6. 완료 작업 또는 후속 처리 확인



## 동적 테스트



### 명세 기반 테스트

- 명세 기반 테스트(블랙박스 테스트)

  - 입력 값에 대한 예상출력 값을 정해놓고 그대로 결과가 나오는지를 체크
  - 프로그램 내부의 구조나 알고리즘을 보지 않고, 요구 분석 명세서나 설계 사양서에서 테스 트 케이스를 추출하여 테스트
  - 기능을 어떻게 수행하는가 보다는 사용자가 원하는 기능을 수행하는가 테스트

  

- 동적 테스트

  - 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는다

- 정보를 얻는 문서 종류에 따른 분류

  - 명세 기반 테스트
  - 구현 기반 테스트



### 신텍스 기법

- 문법에 기반을 둔 테스트
- 문법을 정해놓고 적합/부적합 입력 값에 따른 예상 결과가 제대로 나오는지 테스트



### 동등 분할 기법

- 각 영역에 해당하는 입력 값을 넣고 예상되는 출력 값이 나오는지 실제 값과 비교
- 입력 값에 대한 예상 결과 값을 미리 정해 놓고, 각 영역에서 임의 값을 하나 정해 입 력 값으로 사용하여 실제 결과가 예상 값과 같은지 확인
- 장점: 단순하고 이해하기 쉬우며 사용자가 작성 가능



### 경계 값 분석(boundary value analysis)기법

- 경계에 있는 값을 테스트 데이터로 생성하여 테스트하는 방법
- 경계 값과 경계 이전 값, 경계 이후 값을 가지고 테스트



### 원인-결과 그래프 기법

- 동등 분할/경계 값 분석 기법의 단점: 입력 환경의 복합성을 완전하게 고려하지 못함



1. 프로그램을 적합한 크기로 분할한다
2. 원인과 결과를 찾는다
3. 원인-결과 그래프를 작성한다
4. 그래프에 제한 조건을 표시한다
5. 의사결정 테이블로 변환한다



 ### 구현 기반 테스트

= 화이트 박스 테스트(white box test)

= 코드 기반 테스트(code based test)



- 테스트 데이터 적합성 기준(test data adequacy criterion)
  - 테스트 데이터 생성 기준test data generation criterion
  - 테스트에서 프로그램 코드의 가능한 경로를 모두 테스트할 수 없기 때문에 프로그램의 일 부 경로만 정해 테스트해야 하는데 어떤 경로를 테스트 대상으로 선정할지 결정할 수 있는 기준



#### 화이트박스 테스트 절차

1. 테스트 데이터 적합성 기준 선정
2. 테스트 데이터 생성
3. 테스트 실행



#### 화이트박스 테스트 방법

- 문장 검증 기준
- 분기 검증 기준
- 조건 검증 기준
- 분기/조건 검증 기준
- 다중 조건 검증 기준
- 기본 경로 테스트



#### 기본 경로 테스트

- 원시 코드의 독립적인 경로가 최소한 한 번은 실행되는 테스트 케이스를 찾아 테스트
- 목적: 원시코드의 독립적인 경로를 모두 수행하는 것



1. 순서도 작성
2. 흐름 그래프 작성
3. 순환 복잡도 계산
   - 순환 복잡도(CC: Cyclomatic Complexity)
     - 매케이브가 정의한 메트릭으로 원시 코드의 복잡도를 정량적으로 평가하는 방법
     - 원시 코드가 얼마나 복잡한지를 알아보기 위한 것
     - 얼마나 많은 논리적인 경로를 가지고 있는지 계산한 값
4. 독립적 경로 정의
5. 테스트 케이스 작성



## 소프트웨어 개발 단계에 따른 테스트

- V 모델
  - 소프트웨어 개발 단계의 순서와 짝을 이루어 테스트를 진행해나가는 방법
  - 프로젝트 초기 단계부터 테스트 계획을 세우고, 테스트 설계 과정이 함께 진행



### 단위 테스트

- 단위 테스트, 모듈 테스트(module test)
  - 프로그램의 기본 단위인 모듈을 테스트
  - 모듈 개발 완료한 후 명세서의 내용대로 정확히 구현되었는지를 테스트
  - 개별 모듈이 제대로 구현되어 정해진 기능을 정확히 수행하는지를 테스트
  - 프로그램의 기본 단위인 모듈을 테스트
- 단위 테스트 수행 후 발견되는 오류
  - 잘못 사용한 자료형
  - 잘못된 논리 연산자
  - 알고리즘 오류에 따른 원치 않는 결과
  - 틀린 계산 수식에 의한 잘못된 결과
  - 탈출구가 없는 반복문의 사용



- 모듈 테스트 시 상위/하위 모듈이 개발 안된 경우
  - 가상의 상위나 하위 모듈을 만들어 사용
  - 테스트 드라이버(test driver)
  - 테스트 스텁(stub)



## 통합 테스트

- 통합 테스트(integration test)
  - 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생할 수 있는 오류를 찾는 테스트
  - ‘모듈 간의 상호작용이 정상적으로 수행되는가’ 테스트
  - 모듈 사이의 인터페이스 오류는 없는지, 모듈이 올바르게 연계되어 동작하고 있는지 체크
- 모듈 통합 방법에 따른 분류
  - 한꺼번에 하는 방법: big-bang 테스트
  - 점진적으로 하는 방법: 하향식 기법, 상향식 기법



- Big-bang 테스트

  - 단위테스트가 끝난 모듈을 한꺼번에 결합하여 수행하는 방식
  - 소규모 프로그램이나 프로그램의 일부를 대상으로 하는 경우에 적합
  - 오류 발생 시 어떤 모듈에서 오류가 존재하는지, 그 원인이 무엇인지 찾기가 어려움

  

- 점진적 모듈 통합 방법 : 하향식(top-down) 기법

  - 모듈의 계층 구조에서 맨 상위의 모듈부터 시작하여 점차 하위 모듈 방향으로 통합
  - 모듈의 구성
    - 상위 모듈: 시스템 전체의 흐름 관장
    - 하위 모듈: 각 기능을 구현
  - 장점
    - 프로그램 전체에 영향을 줄 수 있는 오류를 일찍 발견하기가 쉽다.
  - 단점
    - 하위 모듈이 임시로 만든 스텁들로 대체되어 결과가 완전하지 않을 수도 있다.
    - 스텁 수가 많으면 스텁을 만드는 데 시간과 노력이 많이 들 수 있다. 
  - 모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘되고 있는지를 빨리 파악하고자 할 때 유용



- 점진적 모듈 통합 방법 : 상향식(bottom-down) 기법
  - 가장 말단에 있는 최하위 모듈부터 테스트
  - 상위 모듈의 역할을 하는 테스트 드라이버가 필요
  - 드라이버: 하위 모듈을 순서에 맞게 호출하고, 호출할 때 필요한 매개 변수를 제공하며, 반 환 값을 전달하는 역할
  - 장점
    - 최하위 모듈들을 개별적으로 병행하여 테스트
    - 하위에 있는 모듈들을 충분히 테스트 가능
    - 정밀한 계산이나 데이터 처리가 요구되는 시스템 같은 경우에 유용
  - 단점
    - 상위 모듈에 오류가 발견되면 그 모듈과 관련된 하위의 모듈을 다시 테스트해야 함



### 시스템 테스트

- 시스템(system) 테스트
  - 시스템 전체가 정상적으로 작동하는지를 체크
  - 모듈이 모두 통합된 후 사용자의 요구 사항들을 만족하는지 테스트
  - 사용자에게 개발된 시스템을 전달하기 전에 개발자가 진행하는 마지막 테스트
  - V & V에서 확인(verification)에 해당
  - 실제 사용 환경과 유사하게 테스트 환경을 만들어놓고 요구 분석 명세서에 명시한 기능적 요구 사항과 비기능적 요구 사항을 충족하는지 테스트
  - 주로 부하를 주는 상황에서 수행하고, 비기능적 테스트를 중심으로 수행



### 인수 테스트

- 인수 테스트(acceptance test)
  - 시스템이 예상대로 동작하는지 확인하고, 요구 사항에 맞는지 확신하기 위해 하는 테스트
  - 시스템을 인수하기 전 요구 분석 명세서에 명시된 대로 모두 충족시키는지를 사용자가 테스트
  - 목적: 사용자 주도로 이루어지며, 오류 발견보다는 제품의 출시 여부를 판단하는 것
  - 인수 테스트 결과: 시스템을 출시할지, 출시 시기를 늦추더라도 보완할지 결정
  - V & V의 검증(validation)에 해당

- 알파 테스트(alpha test)
  - 내부 필드 테스트
  - 베타 테스트 개발자 환경에서 사용 -> 오류와 사용상의 문제점 파악
- 베타 테스트(beta test)
  - 알파 테스트 후 시장 출시 전 시장의 피드백을 얻기 위한 목적으로 테스트
  - 특정 사용자가 미리 사용 -> 문제점, 오류 발견 -> 개발자에게 알려줌
  - 개발자: 베타 테스트를 통해 보고된 문제점 수정 -> 제품 출시



### 설치 테스트

- 사용자의 환경에서 설치 후 테스트
- 테스트 케이스는 시스템 테스트에서 가져옴



### 회귀 테스트

- 확정 테스트(confirmation test)

  - 원시 코드의 결함을 수정한 후 제대로 수정되었는지 확인하는 테스트

- 회귀 테스트(regression test)

  - 한 모듈의 수정이 다른 부분에 영향을 끼칠 수도 있다고 생각하여 수정된 모듈뿐 아니라 관련된 모듈까지 문제가 없는지 테스트

  1. 수정을 위한 회귀 테스트(corrective regression test)
     - 모든 테스트를 완료하여 사용자에게 전달하기 전에 테스트 과정에서 미처 발견하지 못한 오류를 찾아 수정한 후 다시 테스트
  2. 점진적 회귀 테스트(progressive regression test)
     - 사용 중에 일부 기능을 추가하여 새로운 버전을 만들고, 이 새 버전을 다시 테스트

