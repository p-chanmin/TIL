# UML (Unified Modeling Language)

**통합 모델링 언어**(UML : Unified Modeling Language)는 소프트웨어 공학에서 사용되는 표준화된 범용 모델링 언어이다.

이런 UML은 소프트웨어를 설계하며 필요에 의해서 사용되는데 일반적으로 아래 3가지의 목적을 가지고 만듭니다.

- 의사소통 또는 설계 논의를 위해
- 전체 시스템의 구조 및 클래스의 의존성 파악을 위해
- 유지보수를 위한 설계의 back-end 문서 제작을 위해

[TOC]



## 클래스 ( class )

클래스 다이어그램은 정적 다이어그램으로 클래스의 구성요소 및 클래스간의 관계를 표한하는 대표적인 UML



### 목적

* 문제 해결을 위한 도메인 구조를 나타내어 보이지 않는 도메인 안의 개념과 같은 추상적인 개념을 기술하기 위해

* 소프트웨어의 설계 혹은 완성된 소프트웨어의 구현 설명을 목적



### 구성요소

* **접근 제어자**

  | 접근 제어자 | 의미      |
  | :---------: | --------- |
  |      +      | public    |
  |      -      | private   |
  |      #      | protected |
  |      ~      | default   |

  {readonly} 가 붙으면 **final**을 의미한다.

  밑줄은 **static**을 의미한다.

  {abstract}는 **추상 클래스**를 의미한다.

  [*] 나 [0...1]은 리스트와 같은 변수에 지정된 사이즈를 의미한다.

  

  ![img](https://blog.kakaocdn.net/dn/dpDiUW/btrb8T3sAU9/USvKxTjpTNuNzT4drkr3ek/img.png)

* **형식**

  * **속성(Attribute)**

    {접근 제어자}{필드명} : {타입} = {기본값}

  * **메서드(Method)**

    {접근 제어자}{메소드명}({파라미터 타입}) : {반환 타입}



* **클래스 다이어그램을 이용한 관계 표현**

  ![img](https://www.nextree.co.kr/content/images/2021/01/--6-----------.png)



### 예시

* **Generalization ( 일반화 )**

  ![img](https://www.nextree.co.kr/content/images/2021/01/--7-Generalization1.png)

  Generalization은 우리가 일반적으로 알고 있는 상속을 의미

  클래스 다이어그램에서는 **실선에 비어있는 화살표로 표시**



* **Realization ( 실체화 )**

  ![img](https://www.nextree.co.kr/content/images/2021/01/--8-Realization.png)

  Realization은 interface에 있는 spec을 오버라이딩하여 실제로 구현하는 것

  **Realization은 점선과 비어있는 화살표로 표현**한다.



* **Dependency ( 의존 )**

  ![img](https://www.nextree.co.kr/content/images/2021/01/--9-Dependency.png)

  ![img](https://www.nextree.co.kr/content/images/2021/01/--10-Dependency2.png)

  Dependency는 클래스간의 참조가 일어나는 것으로 **Dependency 참조는 메서드 내에서 대상 클래스의 객체를 생성하거나 사용, 리턴받아 사용하는 것**이다.

  **이 참조는 해당 클래스와의 관계를 계속 유지하지 않는다.**

  dependency는 점선과 화살표로 이루어져 있다.



* **Association & Direct Association ( 연관 )**

  ![img](https://www.nextree.co.kr/content/images/2021/01/--11-Assocication.png)

  **Association은 다른 객체의 참조를 가지는 필드**를 의미한다.

  실선으로 표현되며 방향성이 존재하는 경우에는 화살표를 넣어 표시한다.

  둘의 연관관계가 어떻게 되는지 숫자로 표시할 수 있다.

  - 1 - 1개의 표현
  - \* - 0 ~ n 개의 표현
  - n...m : n 부터 m까지 연관관계를 맺음



* **Aggregation ( 집합 )**

  ![img](https://www.nextree.co.kr/content/images/2021/01/--16-Aggregation.png)

  **Aggregation은 Association의 집합관계를 나타내는 것으로 Collection이나 Array를 이용하는 관계**이다.

  Aggregation 관계는 일반적인 Association으로도 충분히 나타낼 수 있는 관계

  Aggregation은 실선에 빈 다이아몬드로 나타낸다.



* **Composigiton ( 합성 )**

  ![img](https://www.nextree.co.kr/content/images/2021/01/--19-Composition1.png)

  **Composigiton은 클래스 연관관계에서 강한 결합의 관계를 의미**

  **참조하는 클래스의 라이프 사이클이 종속적이다.**

  다이어그램으로는 실선에 채워져있는 다이아몬드로 표시한다.



## 유스케이스( use case )

시스템과 사용자의 상호작용을 다이어그램으로 표현한 것



### 목적

* 사용자의 관점에서 시스템의 서비스 혹은 기능 및 그와 관련한 외부 요소를 보여주기 위해
* 사용자가 시스템 내부에 있는 기능 중에 어떤 기능을 사용 할 수 있는지 나타내기 위해
* 고객과 개발자가 요구사항에 대한 의견을 조율하기 위해
* 사용자랑 시스템사이에 관계를 나타내기 위해



### 구성요소 및 예시

* **System ( 시스템 )**

  ![img](https://t1.daumcdn.net/cfile/tistory/21214C4E594FDAA112)

  만들고자 하는 프로그램을 나타낸다.

  유스케이스들을 둘러싼 사각형 틀로 시스템 명칭을 안쪽 상단에 작성한다.



* **Actor ( 액터 )**

  ![img](https://t1.daumcdn.net/cfile/tistory/2550854E594FDAA108)

  시스템의 외부에 있고 시스템과 상호작용을 하는 사람, 시스템을 의미한다.

  원과 선을 조합하여 사람모양으로 표현한다.

  액터명은 위나 아래에 표시하며 액터의 역할을 작성한다.



* **Usecase ( 유스케이스 )**

  ![img](https://t1.daumcdn.net/cfile/tistory/23218C4E594FDAA225)

  사용자 입장에서 바라본 시스템의 기능

  시스템이 액터에게 제공해야 하는 기능으로 시스템의 요구사항을 의미한다.

  타원으로 표시하고 안쪽에 유스케이스명을 작성한다.

  유스케이스명은 "~한다"와 같이 동사로 표현한다.



* **Relation ( 관계 )**

  연관(Association), 의존(Dependency), 일반화(Generalization)이 있으며 의존관계는 포함(Include), 확장(Extend)로 나눠진다.

  * **연관관계(Association)**

    ![img](https://t1.daumcdn.net/cfile/tistory/2614D049594FD59419)

    유스케이스와 액터간의 상호작용이 있음을 표현

    유스케이스와 액터를 실선으로 연결

    

  * **의존(Dependency)**

    ![img](https://t1.daumcdn.net/cfile/tistory/256EC949594FD5951C)

    포함 관계(Include)는 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 관계

    포함되는 유스케이스는 포함하는 유스케이스를 실행하기 위해 반드시 실행되어야 하는 경우에 적용

    ![img](https://t1.daumcdn.net/cfile/tistory/26341449594FD59535)

    확장 관계(Extend)는 확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성 되는 관계

    확장 대상 유스케이스를 수행 할 때 특정 조건에 따라 확장 기능 유스케이스를 수행하는 경우에 적용

    

  * **일반화 관계(Generalization)**

    ![img](https://t1.daumcdn.net/cfile/tistory/22262A49594FD59636)

    일반화 관계(Generalization)는 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 또는 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계

    구체적인 유스케이스에서 추상적인 유스케이스 방향으로 끝부분이 삼각형으로 표현된 화살표를 실선으로 연결하여 표현한다.



## 순차 (sequence)

순차 다이어그램은 실행 시점에 객체들이 어떻게 상호 동작하는지를 메세지 순서에 초점을 맞춰 나타낸 것



### 목적

* 작업이 객체 간에 발생하는지를 시간 순서에 따라 쉽게 파악하기 위해
* 객체간 상호작용을 정의하는 과정에서 객체들이 가져야 하는 오퍼레이션과 속성을 구체적으로 정의하기 위해



### 구성 요소

* 객체
  * 가장 윗부분에 표현
  * 왼쪽에서 오른쪽으로 객체들을 나열
  * "객체이름 : 클래스이름" 형식으로 표기
* 생명선
  * 객체 아래에 이어지는 점선
  * 해당 객체가 존재함을 의미
* 활성 구간
  * 생명선을 따라서 좁고 긴 사각형
  * 객체가 연산을 실행하는 상태
  * 실행 시간을 고려해서 적당히 설정



* 메세지

  * 객체와 상호작용을 표현하는 것

  * | **유형**      | **의미**                                                     |
    | ------------- | ------------------------------------------------------------ |
    | 동기 메시지   | 메시지 전송 객체가 계속하기 전까지 동기 메시지에 대한 응답을 기다림. 프로그램 내 일반적인 함수 호출과 동일한 동작 방식의 메시지를 표현 |
    | 비동기 메시지 | 메시지 전송 객체가 계속하기 전까지 응답을 요구하기 않는 메시지. 전송 객체의 호출만을 표시.보통 개별 쓰레드 간의 통신 및 새 쓰레드의 생성에 사용 |
    | 자체 메시지   | 자신에게 보낸 메시지입니다. 결과로 생성된 실행 발생이 전송 실행 위에 나타남. |
    | 반환 메시지   | 이전 호출의 반환을 기다리는 객체에게 다시 반환되는 메시지.   |



### 예시

![img](http://itwiki.kr/images/6/6b/%EC%8B%9C%ED%80%80%EC%8A%A4_%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8_%EC%98%88%EC%8B%9C.jpg)



## 통신(communication)

### 목적

* 순차 다이어그램과 마찬가지로 메세지를 이용해 객체 간 상호작용을 나타냄
* 순차 다이어그램은 시간 순서에 초점, 통신 다이어그램은 객체 간 상호작용에 초점을 둠



### 구성요소

* 객체, 메세지
  * 순차 다이어그램과 동일
* 링크
  * 객체 간의 메세지를 주고 받는 관계
  * 링크를 사용해 객체 간의 관계 표현



### 예시





## 활동(activity)

활동 다이어그램은 객체의 행위를 나타내는 것으로 상태 다이어그램을 확장한 것으로 볼 수 있다.



### 목적

* 상위 수준에서 업무의 흐름을 표현하여 구체적인 이벤트 흐름을 나타내기 위해
* 클래스 내부 동작에 대한 알고리즘이나 구체적인 로직을 표현하기 위해
* 업무의 흐름에서 동작과 같은 행위가 수행되는 동안의 활동을 나탸내기 위해



### 구성요소

* 시작점 : 활동의 시작을 나타내며 속이 채워진 원으로 표기
* 종료점 : 활동의 종료를 나타내며 이중 원으로 표기
* 활동 : 일의 처리와 실행을 나타내며 모서리가 둥근 사각형으로 표기
* 전이 : 활동 간의 이동을 나타내며 화살표로 표기



* 분기 : 조건에 의해 주가지 경로로 나뉘는 위치이며 마름모를 사용. 조건문은 마름모 옆에 <<>> 기호로 작성
* 병합 : 분기되어 각 활동을 수행하다가 합쳐지는 위치를 나타내며 분기와 같이 마름모를 사용



* 동기화 막대 : 여러 활동을 병행할 때 사용, 동시 처리의 시작과 끝을 나타냄
* 신호 : 활동 사이의 거래는 제어 신호를 보내는 방식

* 구획면 : 객체 별로 레인을 분류하여 표기



### 예시





## 상태(state)



### 목적

* 객체의 상태는 이벤트 발생이나 시간의 흐름에 따라 바뀌게 되므로 객체의 상태 병화를 나타내기 위해



### 구성요소

* 상태
  * 상태는 객체가 존재할 수 있는 조건
  * 상태 다이어그램을 작성하기 위해서 객체의 존재 가능한 모든 상태가 파악되어야 함
  * 상태는 모서리가 둥근 사각형으로 표현
* 전이
  * 객체의 상태가 바뀌는 것을 나타냄
  * 화살표를 사용해 표현
* 이벤트
  * 객체의 상태를 바뀌게 하는 자극
  * 화살표로 나타낸 전이 위에 <<>>기호를 사용해 작성



### 예시



## 컴포넌트(component)

컴포넌트 다이어그램은 구현 관점에서 정적 모델링을 할 때 사용하는 것



### 목적

* 실행 모듈이 서로 어떤 연관성이 있는지 종속 관계를 나타내기 위해
* 사용자에게 논리적, 물리적 시스템의 구조를 보여주기 위해



### 구성요소

* 컴포넌트
  * 시스템을 구성하는 물리적인 요소로 프로그램 코드를 포함
* 인터페이스
  * 클래스 모양으로 나타내거나 아이콘을 사용해 간략하게 표현
* 의존 관계
  * 서로 영향을 주고받는 관계
  * 컴포넌트 간 연결은 점선 화살표로 나타내며 의존하는 쪽으로 화살표가 연결



### 예시



## 배치(deployment)

배치 다이어그램은 하드웨어 자원을 명시적으로 정의한다



### 목적

* 시스템의 물리적인 요소를 모델링하고 노드간의 관계를 나타내기 위해







## 출처

> https://www.nextree.co.kr/p6753/
>
> https://brownbears.tistory.com/577
>
> https://googry.tistory.com/2
>
> https://jeonghun-ban.github.io/posts/uml/sequence-diagram/
>
> https://itwiki.kr/w/%EC%8B%9C%ED%80%80%EC%8A%A4_%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8
>
> https://codedragon.tistory.com/4125  활동 다이어그램 예시
>
> https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hoi5man&logNo=60129764500 상태 다이어그램 예시
>
> https://1000yun.tistory.com/8 컴포넌트 다이어그램 
>
> 